# coding: utf-8

"""
    The Jira Cloud platform REST API

    Jira Cloud platform REST API documentation  # noqa: E501

    OpenAPI spec version: 1001.0.0-SNAPSHOT-0daa9a9e2722e510da52cb72ee41a43128c97f42
    Contact: ecosystem@atlassian.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class IssueWorklogsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_worklog(self, body, issue_id_or_key, **kwargs):  # noqa: E501
        """Add worklog  # noqa: E501

        Adds a worklog to an issue.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Work on issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_worklog(body, issue_id_or_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, object) body: (required)
        :param str issue_id_or_key: The ID or key the issue. (required)
        :param bool notify_users: Whether users watching the issue are notified by email.
        :param str adjust_estimate: Defines how to update the issue's time estimate, the options are:   *  `new` Sets the estimate to a specific value, defined in `newEstimate`.  *  `leave` Leaves the estimate unchanged.  *  `manual` Reduces the estimate by amount specified in `reduceBy`.  *  `auto` Reduces the estimate by the value of `timeSpent` in the worklog.
        :param str new_estimate: The value to set as the issue's remaining time estimate, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when `adjustEstimate` is `new`.
        :param str reduce_by: The amount to reduce the issue's remaining estimate by, as days (\\#d), hours (\\#h), or minutes (\\#m). For example, *2d*. Required when `adjustEstimate` is `manual`.
        :param str expand: Use [expand](#expansion) to include additional information about work logs in the response. This parameter accepts `properties`, which returns worklog properties.
        :param bool override_editable_flag: Whether the worklog entry should be added to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) can use this flag.
        :return: Worklog
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_worklog_with_http_info(body, issue_id_or_key, **kwargs)  # noqa: E501
        else:
            (data) = self.add_worklog_with_http_info(body, issue_id_or_key, **kwargs)  # noqa: E501
            return data

    def add_worklog_with_http_info(self, body, issue_id_or_key, **kwargs):  # noqa: E501
        """Add worklog  # noqa: E501

        Adds a worklog to an issue.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Work on issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_worklog_with_http_info(body, issue_id_or_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, object) body: (required)
        :param str issue_id_or_key: The ID or key the issue. (required)
        :param bool notify_users: Whether users watching the issue are notified by email.
        :param str adjust_estimate: Defines how to update the issue's time estimate, the options are:   *  `new` Sets the estimate to a specific value, defined in `newEstimate`.  *  `leave` Leaves the estimate unchanged.  *  `manual` Reduces the estimate by amount specified in `reduceBy`.  *  `auto` Reduces the estimate by the value of `timeSpent` in the worklog.
        :param str new_estimate: The value to set as the issue's remaining time estimate, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when `adjustEstimate` is `new`.
        :param str reduce_by: The amount to reduce the issue's remaining estimate by, as days (\\#d), hours (\\#h), or minutes (\\#m). For example, *2d*. Required when `adjustEstimate` is `manual`.
        :param str expand: Use [expand](#expansion) to include additional information about work logs in the response. This parameter accepts `properties`, which returns worklog properties.
        :param bool override_editable_flag: Whether the worklog entry should be added to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) can use this flag.
        :return: Worklog
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'issue_id_or_key', 'notify_users', 'adjust_estimate', 'new_estimate', 'reduce_by', 'expand', 'override_editable_flag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_worklog" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_worklog`")  # noqa: E501
        # verify the required parameter 'issue_id_or_key' is set
        if ('issue_id_or_key' not in params or
                params['issue_id_or_key'] is None):
            raise ValueError("Missing the required parameter `issue_id_or_key` when calling `add_worklog`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'issue_id_or_key' in params:
            path_params['issueIdOrKey'] = params['issue_id_or_key']  # noqa: E501

        query_params = []
        if 'notify_users' in params:
            query_params.append(('notifyUsers', params['notify_users']))  # noqa: E501
        if 'adjust_estimate' in params:
            query_params.append(('adjustEstimate', params['adjust_estimate']))  # noqa: E501
        if 'new_estimate' in params:
            query_params.append(('newEstimate', params['new_estimate']))  # noqa: E501
        if 'reduce_by' in params:
            query_params.append(('reduceBy', params['reduce_by']))  # noqa: E501
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501
        if 'override_editable_flag' in params:
            query_params.append(('overrideEditableFlag', params['override_editable_flag']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/api/3/issue/{issueIdOrKey}/worklog', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Worklog',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_delete_worklogs(self, body, issue_id_or_key, **kwargs):  # noqa: E501
        """Bulk delete worklogs  # noqa: E501

        Deletes a list of worklogs from an issue. This is an experimental API with limitations:   *  You can't delete more than 5000 worklogs at once.  *  No notifications will be sent for deleted worklogs.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  *Delete all worklogs*[ project permission](https://confluence.atlassian.com/x/yodKLg) to delete any worklog.  *  If any worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_delete_worklogs(body, issue_id_or_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WorklogIdsRequestBean body: A JSON object containing a list of worklog IDs. (required)
        :param str issue_id_or_key: The ID or key of the issue. (required)
        :param str adjust_estimate: Defines how to update the issue's time estimate, the options are:   *  `leave` Leaves the estimate unchanged.  *  `auto` Reduces the estimate by the aggregate value of `timeSpent` across all worklogs being deleted.
        :param bool override_editable_flag: Whether the work log entries should be removed to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with admin permission can use this flag.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_delete_worklogs_with_http_info(body, issue_id_or_key, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_delete_worklogs_with_http_info(body, issue_id_or_key, **kwargs)  # noqa: E501
            return data

    def bulk_delete_worklogs_with_http_info(self, body, issue_id_or_key, **kwargs):  # noqa: E501
        """Bulk delete worklogs  # noqa: E501

        Deletes a list of worklogs from an issue. This is an experimental API with limitations:   *  You can't delete more than 5000 worklogs at once.  *  No notifications will be sent for deleted worklogs.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  *Delete all worklogs*[ project permission](https://confluence.atlassian.com/x/yodKLg) to delete any worklog.  *  If any worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_delete_worklogs_with_http_info(body, issue_id_or_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WorklogIdsRequestBean body: A JSON object containing a list of worklog IDs. (required)
        :param str issue_id_or_key: The ID or key of the issue. (required)
        :param str adjust_estimate: Defines how to update the issue's time estimate, the options are:   *  `leave` Leaves the estimate unchanged.  *  `auto` Reduces the estimate by the aggregate value of `timeSpent` across all worklogs being deleted.
        :param bool override_editable_flag: Whether the work log entries should be removed to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with admin permission can use this flag.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'issue_id_or_key', 'adjust_estimate', 'override_editable_flag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_delete_worklogs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_delete_worklogs`")  # noqa: E501
        # verify the required parameter 'issue_id_or_key' is set
        if ('issue_id_or_key' not in params or
                params['issue_id_or_key'] is None):
            raise ValueError("Missing the required parameter `issue_id_or_key` when calling `bulk_delete_worklogs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'issue_id_or_key' in params:
            path_params['issueIdOrKey'] = params['issue_id_or_key']  # noqa: E501

        query_params = []
        if 'adjust_estimate' in params:
            query_params.append(('adjustEstimate', params['adjust_estimate']))  # noqa: E501
        if 'override_editable_flag' in params:
            query_params.append(('overrideEditableFlag', params['override_editable_flag']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/api/3/issue/{issueIdOrKey}/worklog', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_move_worklogs(self, body, issue_id_or_key, **kwargs):  # noqa: E501
        """Bulk move worklogs  # noqa: E501

        Moves a list of worklogs from one issue to another. This is an experimental API with several limitations:   *  You can't move more than 5000 worklogs at once.  *  You can't move worklogs containing an attachment.  *  You can't move worklogs restricted by project roles.  *  No notifications will be sent for moved worklogs.  *  No webhooks or events will be sent for moved worklogs.  *  No issue history will be recorded for moved worklogs.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the projects containing the source and destination issues.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  *Delete all worklogs*[ and *Edit all worklogs*](https://confluence.atlassian.com/x/yodKLg)[project permission](https://confluence.atlassian.com/x/yodKLg)  *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_move_worklogs(body, issue_id_or_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WorklogsMoveRequestBean body: A JSON object containing a list of worklog IDs and the ID or key of the destination issue. (required)
        :param str issue_id_or_key: (required)
        :param str adjust_estimate: Defines how to update the issues' time estimate, the options are:   *  `leave` Leaves the estimate unchanged.  *  `auto` Reduces the estimate by the aggregate value of `timeSpent` across all worklogs being moved in the source issue, and increases it in the destination issue.
        :param bool override_editable_flag: Whether the work log entry should be moved to and from the issues even if the issues are not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with admin permission can use this flag.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_move_worklogs_with_http_info(body, issue_id_or_key, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_move_worklogs_with_http_info(body, issue_id_or_key, **kwargs)  # noqa: E501
            return data

    def bulk_move_worklogs_with_http_info(self, body, issue_id_or_key, **kwargs):  # noqa: E501
        """Bulk move worklogs  # noqa: E501

        Moves a list of worklogs from one issue to another. This is an experimental API with several limitations:   *  You can't move more than 5000 worklogs at once.  *  You can't move worklogs containing an attachment.  *  You can't move worklogs restricted by project roles.  *  No notifications will be sent for moved worklogs.  *  No webhooks or events will be sent for moved worklogs.  *  No issue history will be recorded for moved worklogs.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the projects containing the source and destination issues.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  *Delete all worklogs*[ and *Edit all worklogs*](https://confluence.atlassian.com/x/yodKLg)[project permission](https://confluence.atlassian.com/x/yodKLg)  *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_move_worklogs_with_http_info(body, issue_id_or_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WorklogsMoveRequestBean body: A JSON object containing a list of worklog IDs and the ID or key of the destination issue. (required)
        :param str issue_id_or_key: (required)
        :param str adjust_estimate: Defines how to update the issues' time estimate, the options are:   *  `leave` Leaves the estimate unchanged.  *  `auto` Reduces the estimate by the aggregate value of `timeSpent` across all worklogs being moved in the source issue, and increases it in the destination issue.
        :param bool override_editable_flag: Whether the work log entry should be moved to and from the issues even if the issues are not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with admin permission can use this flag.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'issue_id_or_key', 'adjust_estimate', 'override_editable_flag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_move_worklogs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_move_worklogs`")  # noqa: E501
        # verify the required parameter 'issue_id_or_key' is set
        if ('issue_id_or_key' not in params or
                params['issue_id_or_key'] is None):
            raise ValueError("Missing the required parameter `issue_id_or_key` when calling `bulk_move_worklogs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'issue_id_or_key' in params:
            path_params['issueIdOrKey'] = params['issue_id_or_key']  # noqa: E501

        query_params = []
        if 'adjust_estimate' in params:
            query_params.append(('adjustEstimate', params['adjust_estimate']))  # noqa: E501
        if 'override_editable_flag' in params:
            query_params.append(('overrideEditableFlag', params['override_editable_flag']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/api/3/issue/{issueIdOrKey}/worklog/move', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_worklog(self, issue_id_or_key, id, **kwargs):  # noqa: E501
        """Delete worklog  # noqa: E501

        Deletes a worklog from an issue.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  *Delete all worklogs*[ project permission](https://confluence.atlassian.com/x/yodKLg) to delete any worklog or *Delete own worklogs* to delete worklogs created by the user,  *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_worklog(issue_id_or_key, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str issue_id_or_key: The ID or key of the issue. (required)
        :param str id: The ID of the worklog. (required)
        :param bool notify_users: Whether users watching the issue are notified by email.
        :param str adjust_estimate: Defines how to update the issue's time estimate, the options are:   *  `new` Sets the estimate to a specific value, defined in `newEstimate`.  *  `leave` Leaves the estimate unchanged.  *  `manual` Increases the estimate by amount specified in `increaseBy`.  *  `auto` Reduces the estimate by the value of `timeSpent` in the worklog.
        :param str new_estimate: The value to set as the issue's remaining time estimate, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when `adjustEstimate` is `new`.
        :param str increase_by: The amount to increase the issue's remaining estimate by, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when `adjustEstimate` is `manual`.
        :param bool override_editable_flag: Whether the work log entry should be added to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with admin permission can use this flag.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_worklog_with_http_info(issue_id_or_key, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_worklog_with_http_info(issue_id_or_key, id, **kwargs)  # noqa: E501
            return data

    def delete_worklog_with_http_info(self, issue_id_or_key, id, **kwargs):  # noqa: E501
        """Delete worklog  # noqa: E501

        Deletes a worklog from an issue.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  *Delete all worklogs*[ project permission](https://confluence.atlassian.com/x/yodKLg) to delete any worklog or *Delete own worklogs* to delete worklogs created by the user,  *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_worklog_with_http_info(issue_id_or_key, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str issue_id_or_key: The ID or key of the issue. (required)
        :param str id: The ID of the worklog. (required)
        :param bool notify_users: Whether users watching the issue are notified by email.
        :param str adjust_estimate: Defines how to update the issue's time estimate, the options are:   *  `new` Sets the estimate to a specific value, defined in `newEstimate`.  *  `leave` Leaves the estimate unchanged.  *  `manual` Increases the estimate by amount specified in `increaseBy`.  *  `auto` Reduces the estimate by the value of `timeSpent` in the worklog.
        :param str new_estimate: The value to set as the issue's remaining time estimate, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when `adjustEstimate` is `new`.
        :param str increase_by: The amount to increase the issue's remaining estimate by, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when `adjustEstimate` is `manual`.
        :param bool override_editable_flag: Whether the work log entry should be added to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with admin permission can use this flag.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['issue_id_or_key', 'id', 'notify_users', 'adjust_estimate', 'new_estimate', 'increase_by', 'override_editable_flag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_worklog" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'issue_id_or_key' is set
        if ('issue_id_or_key' not in params or
                params['issue_id_or_key'] is None):
            raise ValueError("Missing the required parameter `issue_id_or_key` when calling `delete_worklog`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_worklog`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'issue_id_or_key' in params:
            path_params['issueIdOrKey'] = params['issue_id_or_key']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'notify_users' in params:
            query_params.append(('notifyUsers', params['notify_users']))  # noqa: E501
        if 'adjust_estimate' in params:
            query_params.append(('adjustEstimate', params['adjust_estimate']))  # noqa: E501
        if 'new_estimate' in params:
            query_params.append(('newEstimate', params['new_estimate']))  # noqa: E501
        if 'increase_by' in params:
            query_params.append(('increaseBy', params['increase_by']))  # noqa: E501
        if 'override_editable_flag' in params:
            query_params.append(('overrideEditableFlag', params['override_editable_flag']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['OAuth2', 'basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/api/3/issue/{issueIdOrKey}/worklog/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ids_of_worklogs_deleted_since(self, **kwargs):  # noqa: E501
        """Get IDs of deleted worklogs  # noqa: E501

        Returns a list of IDs and delete timestamps for worklogs deleted after a date and time.  This resource is paginated, with a limit of 1000 worklogs per page. Each page lists worklogs from oldest to youngest. If the number of items in the date range exceeds 1000, `until` indicates the timestamp of the youngest item on the page. Also, `nextPage` provides the URL for the next page of worklogs. The `lastPage` parameter is set to true on the last page of worklogs.  This resource does not return worklogs deleted during the minute preceding the request.  **[Permissions](#permissions) required:** Permission to access Jira.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ids_of_worklogs_deleted_since(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int since: The date and time, as a UNIX timestamp in milliseconds, after which deleted worklogs are returned.
        :return: ChangedWorklogs
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ids_of_worklogs_deleted_since_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_ids_of_worklogs_deleted_since_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_ids_of_worklogs_deleted_since_with_http_info(self, **kwargs):  # noqa: E501
        """Get IDs of deleted worklogs  # noqa: E501

        Returns a list of IDs and delete timestamps for worklogs deleted after a date and time.  This resource is paginated, with a limit of 1000 worklogs per page. Each page lists worklogs from oldest to youngest. If the number of items in the date range exceeds 1000, `until` indicates the timestamp of the youngest item on the page. Also, `nextPage` provides the URL for the next page of worklogs. The `lastPage` parameter is set to true on the last page of worklogs.  This resource does not return worklogs deleted during the minute preceding the request.  **[Permissions](#permissions) required:** Permission to access Jira.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ids_of_worklogs_deleted_since_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int since: The date and time, as a UNIX timestamp in milliseconds, after which deleted worklogs are returned.
        :return: ChangedWorklogs
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['since']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ids_of_worklogs_deleted_since" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/api/3/worklog/deleted', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ChangedWorklogs',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ids_of_worklogs_modified_since(self, **kwargs):  # noqa: E501
        """Get IDs of updated worklogs  # noqa: E501

        Returns a list of IDs and update timestamps for worklogs updated after a date and time.  This resource is paginated, with a limit of 1000 worklogs per page. Each page lists worklogs from oldest to youngest. If the number of items in the date range exceeds 1000, `until` indicates the timestamp of the youngest item on the page. Also, `nextPage` provides the URL for the next page of worklogs. The `lastPage` parameter is set to true on the last page of worklogs.  This resource does not return worklogs updated during the minute preceding the request.  **[Permissions](#permissions) required:** Permission to access Jira, however, worklogs are only returned where either of the following is true:   *  the worklog is set as *Viewable by All Users*.  *  the user is a member of a project role or group with permission to view the worklog.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ids_of_worklogs_modified_since(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int since: The date and time, as a UNIX timestamp in milliseconds, after which updated worklogs are returned.
        :param str expand: Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts `properties` that returns the properties of each worklog.
        :return: ChangedWorklogs
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ids_of_worklogs_modified_since_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_ids_of_worklogs_modified_since_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_ids_of_worklogs_modified_since_with_http_info(self, **kwargs):  # noqa: E501
        """Get IDs of updated worklogs  # noqa: E501

        Returns a list of IDs and update timestamps for worklogs updated after a date and time.  This resource is paginated, with a limit of 1000 worklogs per page. Each page lists worklogs from oldest to youngest. If the number of items in the date range exceeds 1000, `until` indicates the timestamp of the youngest item on the page. Also, `nextPage` provides the URL for the next page of worklogs. The `lastPage` parameter is set to true on the last page of worklogs.  This resource does not return worklogs updated during the minute preceding the request.  **[Permissions](#permissions) required:** Permission to access Jira, however, worklogs are only returned where either of the following is true:   *  the worklog is set as *Viewable by All Users*.  *  the user is a member of a project role or group with permission to view the worklog.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ids_of_worklogs_modified_since_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int since: The date and time, as a UNIX timestamp in milliseconds, after which updated worklogs are returned.
        :param str expand: Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts `properties` that returns the properties of each worklog.
        :return: ChangedWorklogs
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['since', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ids_of_worklogs_modified_since" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/api/3/worklog/updated', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ChangedWorklogs',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_issue_worklog(self, issue_id_or_key, **kwargs):  # noqa: E501
        """Get issue worklogs  # noqa: E501

        Returns worklogs for an issue (ordered by created time), starting from the oldest worklog or from the worklog started on or after a date and time.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** Workloads are only returned where the user has:   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_issue_worklog(issue_id_or_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str issue_id_or_key: The ID or key of the issue. (required)
        :param int start_at: The index of the first item to return in a page of results (page offset).
        :param int max_results: The maximum number of items to return per page.
        :param int started_after: The worklog start date and time, as a UNIX timestamp in milliseconds, after which worklogs are returned.
        :param int started_before: The worklog start date and time, as a UNIX timestamp in milliseconds, before which worklogs are returned.
        :param str expand: Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts`properties`, which returns worklog properties.
        :return: PageOfWorklogs
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_issue_worklog_with_http_info(issue_id_or_key, **kwargs)  # noqa: E501
        else:
            (data) = self.get_issue_worklog_with_http_info(issue_id_or_key, **kwargs)  # noqa: E501
            return data

    def get_issue_worklog_with_http_info(self, issue_id_or_key, **kwargs):  # noqa: E501
        """Get issue worklogs  # noqa: E501

        Returns worklogs for an issue (ordered by created time), starting from the oldest worklog or from the worklog started on or after a date and time.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** Workloads are only returned where the user has:   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_issue_worklog_with_http_info(issue_id_or_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str issue_id_or_key: The ID or key of the issue. (required)
        :param int start_at: The index of the first item to return in a page of results (page offset).
        :param int max_results: The maximum number of items to return per page.
        :param int started_after: The worklog start date and time, as a UNIX timestamp in milliseconds, after which worklogs are returned.
        :param int started_before: The worklog start date and time, as a UNIX timestamp in milliseconds, before which worklogs are returned.
        :param str expand: Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts`properties`, which returns worklog properties.
        :return: PageOfWorklogs
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['issue_id_or_key', 'start_at', 'max_results', 'started_after', 'started_before', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_issue_worklog" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'issue_id_or_key' is set
        if ('issue_id_or_key' not in params or
                params['issue_id_or_key'] is None):
            raise ValueError("Missing the required parameter `issue_id_or_key` when calling `get_issue_worklog`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'issue_id_or_key' in params:
            path_params['issueIdOrKey'] = params['issue_id_or_key']  # noqa: E501

        query_params = []
        if 'start_at' in params:
            query_params.append(('startAt', params['start_at']))  # noqa: E501
        if 'max_results' in params:
            query_params.append(('maxResults', params['max_results']))  # noqa: E501
        if 'started_after' in params:
            query_params.append(('startedAfter', params['started_after']))  # noqa: E501
        if 'started_before' in params:
            query_params.append(('startedBefore', params['started_before']))  # noqa: E501
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/api/3/issue/{issueIdOrKey}/worklog', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PageOfWorklogs',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_worklog(self, issue_id_or_key, id, **kwargs):  # noqa: E501
        """Get worklog  # noqa: E501

        Returns a worklog.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_worklog(issue_id_or_key, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str issue_id_or_key: The ID or key of the issue. (required)
        :param str id: The ID of the worklog. (required)
        :param str expand: Use [expand](#expansion) to include additional information about work logs in the response. This parameter accepts  `properties`, which returns worklog properties.
        :return: Worklog
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_worklog_with_http_info(issue_id_or_key, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_worklog_with_http_info(issue_id_or_key, id, **kwargs)  # noqa: E501
            return data

    def get_worklog_with_http_info(self, issue_id_or_key, id, **kwargs):  # noqa: E501
        """Get worklog  # noqa: E501

        Returns a worklog.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_worklog_with_http_info(issue_id_or_key, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str issue_id_or_key: The ID or key of the issue. (required)
        :param str id: The ID of the worklog. (required)
        :param str expand: Use [expand](#expansion) to include additional information about work logs in the response. This parameter accepts  `properties`, which returns worklog properties.
        :return: Worklog
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['issue_id_or_key', 'id', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_worklog" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'issue_id_or_key' is set
        if ('issue_id_or_key' not in params or
                params['issue_id_or_key'] is None):
            raise ValueError("Missing the required parameter `issue_id_or_key` when calling `get_worklog`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_worklog`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'issue_id_or_key' in params:
            path_params['issueIdOrKey'] = params['issue_id_or_key']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/api/3/issue/{issueIdOrKey}/worklog/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Worklog',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_worklogs_for_ids(self, body, **kwargs):  # noqa: E501
        """Get worklogs  # noqa: E501

        Returns worklog details for a list of worklog IDs.  The returned list of worklogs is limited to 1000 items.  **[Permissions](#permissions) required:** Permission to access Jira, however, worklogs are only returned where either of the following is true:   *  the worklog is set as *Viewable by All Users*.  *  the user is a member of a project role or group with permission to view the worklog.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_worklogs_for_ids(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WorklogIdsRequestBean body: A JSON object containing a list of worklog IDs. (required)
        :param str expand: Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts `properties` that returns the properties of each worklog.
        :return: list[Worklog]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_worklogs_for_ids_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.get_worklogs_for_ids_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def get_worklogs_for_ids_with_http_info(self, body, **kwargs):  # noqa: E501
        """Get worklogs  # noqa: E501

        Returns worklog details for a list of worklog IDs.  The returned list of worklogs is limited to 1000 items.  **[Permissions](#permissions) required:** Permission to access Jira, however, worklogs are only returned where either of the following is true:   *  the worklog is set as *Viewable by All Users*.  *  the user is a member of a project role or group with permission to view the worklog.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_worklogs_for_ids_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WorklogIdsRequestBean body: A JSON object containing a list of worklog IDs. (required)
        :param str expand: Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts `properties` that returns the properties of each worklog.
        :return: list[Worklog]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_worklogs_for_ids" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `get_worklogs_for_ids`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/api/3/worklog/list', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Worklog]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_worklog(self, body, issue_id_or_key, id, **kwargs):  # noqa: E501
        """Update worklog  # noqa: E501

        Updates a worklog.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  *Edit all worklogs*[ project permission](https://confluence.atlassian.com/x/yodKLg) to update any worklog or *Edit own worklogs* to update worklogs created by the user.  *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_worklog(body, issue_id_or_key, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, object) body: (required)
        :param str issue_id_or_key: The ID or key the issue. (required)
        :param str id: The ID of the worklog. (required)
        :param bool notify_users: Whether users watching the issue are notified by email.
        :param str adjust_estimate: Defines how to update the issue's time estimate, the options are:   *  `new` Sets the estimate to a specific value, defined in `newEstimate`.  *  `leave` Leaves the estimate unchanged.  *  `auto` Updates the estimate by the difference between the original and updated value of `timeSpent` or `timeSpentSeconds`.
        :param str new_estimate: The value to set as the issue's remaining time estimate, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when `adjustEstimate` is `new`.
        :param str expand: Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts `properties`, which returns worklog properties.
        :param bool override_editable_flag: Whether the worklog should be added to the issue even if the issue is not editable. For example, because the issue is closed. Connect and Forge app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) can use this flag.
        :return: Worklog
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_worklog_with_http_info(body, issue_id_or_key, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_worklog_with_http_info(body, issue_id_or_key, id, **kwargs)  # noqa: E501
            return data

    def update_worklog_with_http_info(self, body, issue_id_or_key, id, **kwargs):  # noqa: E501
        """Update worklog  # noqa: E501

        Updates a worklog.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  *Edit all worklogs*[ project permission](https://confluence.atlassian.com/x/yodKLg) to update any worklog or *Edit own worklogs* to update worklogs created by the user.  *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_worklog_with_http_info(body, issue_id_or_key, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, object) body: (required)
        :param str issue_id_or_key: The ID or key the issue. (required)
        :param str id: The ID of the worklog. (required)
        :param bool notify_users: Whether users watching the issue are notified by email.
        :param str adjust_estimate: Defines how to update the issue's time estimate, the options are:   *  `new` Sets the estimate to a specific value, defined in `newEstimate`.  *  `leave` Leaves the estimate unchanged.  *  `auto` Updates the estimate by the difference between the original and updated value of `timeSpent` or `timeSpentSeconds`.
        :param str new_estimate: The value to set as the issue's remaining time estimate, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when `adjustEstimate` is `new`.
        :param str expand: Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts `properties`, which returns worklog properties.
        :param bool override_editable_flag: Whether the worklog should be added to the issue even if the issue is not editable. For example, because the issue is closed. Connect and Forge app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) can use this flag.
        :return: Worklog
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'issue_id_or_key', 'id', 'notify_users', 'adjust_estimate', 'new_estimate', 'expand', 'override_editable_flag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_worklog" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_worklog`")  # noqa: E501
        # verify the required parameter 'issue_id_or_key' is set
        if ('issue_id_or_key' not in params or
                params['issue_id_or_key'] is None):
            raise ValueError("Missing the required parameter `issue_id_or_key` when calling `update_worklog`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_worklog`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'issue_id_or_key' in params:
            path_params['issueIdOrKey'] = params['issue_id_or_key']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'notify_users' in params:
            query_params.append(('notifyUsers', params['notify_users']))  # noqa: E501
        if 'adjust_estimate' in params:
            query_params.append(('adjustEstimate', params['adjust_estimate']))  # noqa: E501
        if 'new_estimate' in params:
            query_params.append(('newEstimate', params['new_estimate']))  # noqa: E501
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501
        if 'override_editable_flag' in params:
            query_params.append(('overrideEditableFlag', params['override_editable_flag']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/api/3/issue/{issueIdOrKey}/worklog/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Worklog',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
